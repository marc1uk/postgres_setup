#!/bin/bash
# construct the set of commands to execute, to be stored for posterity
BUILDLOG=build.log
BUILDSTEPS=build_steps.sh
echo "" > ${BUILDLOG}
echo "" > ${BUILDSTEPS}
# enclosing the entire thing between single quotes is essential to stop bash from
# replacing things like "id" and "date" with shell command outputs!
echo "constructing set of steps to build table";
exec 3< ./run_table_names.txt  # open table names as file descriptor 3
# n.b. read -r argument prevents backslashes forming escape chars - take lines literally
while read -r TABLE <&3; do  # iterate over lines of file 3.
	echo "Making table $TABLE";
	echo "" > $BUILDSTEPS
	echo "CREATE TABLE $TABLE (" >> ${BUILDSTEPS}
	echo "adding columns...";
	FIRSTLINE="1";
	while read COLUMN; do
		if [ "$FIRSTLINE" == "1" ]; then
			FIRSTLINE="0"
		else
			echo "," >> ${BUILDSTEPS};
		fi
		IFS=' ' read -r NAME TYPE <<<$COLUMN
		NEXTCOLUMN="    $NAME $TYPE";
		if [ "$NAME" == "id" ]; then
			NEXTCOLUMN="${NEXTCOLUMN} PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY";
		else
			NEXTCOLUMN="${NEXTCOLUMN}"
		fi
		echo "${NEXTCOLUMN}";
		echo -n "${NEXTCOLUMN}" >> ${BUILDSTEPS}
	done < ${TABLE}_columns.txt
	echo "" >> ${BUILDSTEPS}
	echo ");" >> ${BUILDSTEPS}
	echo "" >> ${BUILDSTEPS}

	echo "" >> ${BUILDSTEPS}

	# now execute those steps
	echo "please inspect ${BUILDSTEPS}. Do you wish to continue with these actions?"
	select result in Yes No Skip; do
		if [ "$result" == "Yes" ] || [ "$result" == "No" ] || [ "$result" == "Skip" ]; then
			echo "$result";
			if [ "$result" == "No" ]; then
				echo "terminating.";
				exit;
			elif [ "$result" == "Skip" ]; then
				echo "skipping";
				break;
			else
				echo "continuing";
				break;
			fi
		else
			echo "please enter 1 or 2";
		fi;
	done
	if [ "$result" == "Skip" ]; then
		continue;
	fi
	# TODO split this up?
	#echo "will send following to psql:"
	#tr '\n' ' ' < ${BUILDSTEPS}
	#echo "";"end of command"
	tr '\n' ' ' < ${BUILDSTEPS} | psql -d "dbname=rundb"
	cat ${BUILDSTEPS} >> ${BUILDLOG}
	# this doesn't work because multiline commands get split up
	# (e.g. `echo "CREATE Table run ( " | tee psql -U` )
	#let LINE=0
	#while read STEP; do
	#	echo "$STEP" | psql -U postgres
	#	let LINE=$LINE+1
	#	echo "$LINE";  # so we can track where it fell over if something goes wrong
	#done < ${BUILDSTEPS}
	echo "finished";

done
exec 3>&-  # close file descriptor 3
echo "Completed table creation. Resulting database structure:"
echo "\dt+" | psql -d "dbname=rundb"

# cleanup
rm ${BUILDSTEPS}
